# Chapter 1. 오브젝트와 의존관계

## 1.1 초난감 DAO
### [1) step1](step1/UserDao.java)

#### 코드의 문제점
- 변화에 유연하지 못하다.
- 변화에 대비하는 가장 좋은 방법은 변화의 폭을 줄이는 것이다.
- '분리와 확장'을 고려한 설계는 변화에 유연하게 대응할 수 있다.
- 프로그래밍의 기초 개념중 '관심사의 분리'를 객체지향에 적용하여야 한다.

**add() 메서드의 문제점**
- 3가지의 관점이 존재한다.
- 1\) DB와 연결을 위한 괌심
- 2\) 쿼리를 날리는 관심
- 3\) 사용 리소스를 반환하는 관심

---

## 1.2 DAO 분리
### [2) step2](step2/UserDao.java)
- 커넥션을 메서드로 추출하여 유연한 코드로 설계

### [3) step3](step3)
- 추상 클래스로 구현하여 상속을 통한 확장 지원
- 부모 클래스에서 기본적인 로직의 흐름을 정의하고 일부를 서브 클래스에서 구현하게하는 "템플릿 메서드 패턴" 적용
- **이는 스프링에서 애용되는 디자인 패턴 중 하나이다**
- 또 해당 코드는 다른 메서드에서 사용할 객체를 서브클래스에서 결정하는 "팩토리 메서드 패턴"도 적용되었다.

> 이 두가지 패턴을 사용하면 관심사항이 다른 코드를 분리해내 서로 독립적으로 변경, 확장 가능하게 설계할 수 있는 간단하면서도 효과있는 방법이다.

**하지만 상속을 사용했다는 단점이 존재한다.**
- 단지 커넥션 객체를 가져오기 위해 상속구조를 만들면 다른 목적으로 UserDao를 상속하기 힘들다.
- 상속을 통한 상하위 클래스의 관계는 결합도가 강하다.

---

## 1.3 DAO 확장
### [4) step4](./step4)
- 추상클래스를 만들어서 변화가 필요한 부분을 분리하여 독립적으로 변경할 수 있게 했지만, 상속이라는 방법을 사용한 단점이 존재한다.
- DB 커넥션과 관련된 부분을 서브 클래스가 아닌 별도에 클래스를 담으면 상속이 필요없고 독립된 클래스를 만들 수 있다.
- 오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 참조를 갖고 있는 방식으로 만들어진다.
- 제3인 오브젝트인 클라이언트(UserDaoTest)에서 자신이 사용할 커넥션을 직접 선택하도록 책임을 넘겨주도록 설계한다면 UserDao는 오직 인터페이스에 대해서만 의존하면 된다.

> 이렇게 인터페이스를 도입하고 클라이언트의 도움을 얻는 방법은 상속을 사용해 비슷한 시도를 했을 경우보다 훨씬 유연하게 설계가 가능하다.
> 아무리 DAO가 많아져도 DB 접속 방법에 대한 관심은 오직 ConnectionMaker으로 집중된다.

- UserDao는 **전략 패턴을** 이용해 인스턴스를 생성할 때 클라이언트가 선택한 ConnectionMaker의 구현체를 파라미터로 받아 사용하게 된다.

#### 개방 폐쇠 원칙
- 클래스나 모듈은 확장에는 열려있고 변경에는 닫혀있어야한다는 원칙을 UserDao를 지키고 있다.
- 먼저 Connection에 대한 기능을 확장하는데에 열려있다.
- UserDao에 전혀 영향을 주지 않고 언제든지 확장이 가능하다.
- 동시에 핵심 기능을 구현한 코드는 변화에 영향을 받지않고 유지할 수 있으므로 닫혀있다고 할 수 있다.

> 잘 설계된 객체지향 클래스 구조는 이 원칙을 아주 잘 지키고 있다.

#### 높은 응집도와 낮은 결합도
- 응집도란 특정 모듈, 클래스에 얼마만큼 하나의 책임, 관심사에 집중되어있는지에 대한 정도이다.
- 결합도란 오브젝트들 간에 의존하고 있는 정도를 나타낸다.

**높은 응집도**
- 응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것이다.
- 어떤 변경이 일어날 때 모듈의 일부분에만 변경이 일어난다면 어떤 부분이 변경되었는지, 그 변경으로 인한 영향이 무엇인지에 대해 생각해야한다.
- 초난감 DAO는 커넥션 변경이 일어날 때 UserDao의 일부분만 변경된다. 그러므로 해당 변경시 일어날 영향에 대해 일일히 확인해야 한다.
- ConnectionMaker인터페이스일 경우 커넥션 변경이 일어나면 새로운 구현체를 만들기만 하면된다. 이는 UserDao에게 전혀 영향을 주지 않는다.

**낮은 결합도**
- 관계는 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요없게 만들어 결합도는 낮추는 것이 좋다.
- 결합도가 낮아지면 변화에 대응하기 쉬워지고, 구성이 깔끔해진다.
- UserDao는 커넥션을 만들기 위해 꼭 필요한 ConnectionMaker에만 의존하고 있지 해당 구현체에는 전혀 의존하고 있지 않다.

---
## 1.4 제어의 역전(IoC)

### [5) step5](./step5)
- UserDao의 확장성을 위해 UserDaoTest가 커넥션의 구현체를 생성할 책임을 떠맡았다.
- 하지만 UserDaoTest는 테스트를 위한 책임을 가지고 있지 커넥션 생성에 대한 책임을 가지고 있지 않다.
- 기능을 분리하여 UserDao와 ConnectionMaker 구현 클래스의 오브젝트를 만드는 것과, 그렇게 만들어진 두 개의 오브젝트가 연결돼서 사용될 수 있도록 관계를 맺어주자.

**팩토리**
- 객체의 생성 방법을 결정하고 만들어진 오브젝트를 돌려주는 것을 흔히 팩토리라고 부른다.
- 디자인 패턴에서 말하는 팩토리 패턴이 아닌 **단지 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적이다.**


> - 이를 통해 UserDao와 ConnectionMaker는 각 애플리케이션의 핵심적인 데이터 로직, 기술 로직을 담당한다.
> - DaoFactory는 이런 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡고 있다.

### [6) step6](./step6)
- AccountDao, MessageDao가 필요해져서 팩토리를 통해 새로 만들었다.
- 팩토리를 보면 중복되는 코드가 발생한 것을 알 수 있다.
- 중복되는 코드는 분리해내는것이 좋다.

#### 1.4.3 제어권 이전을 통한 제어관계 역전
- 일반적인 프로그래밍 흐름은 main()과 같이 프로그램의 시작 시점에서 각 오브젝트들을 결정해나간다.
- 제어의 역전은 이러한 제어의 흐름을 뒤집어서 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않게하는 것이다.
- 다른 대상에게 제어권을 위임하여 해당 오브젝트가 어디서 어떻게 만들어지는지는 알 수 없다.
- 사실 main()과 같은 엔트리 포인트를 제외한 모든 오브젝트는 이러한 위임을 통해 오브젝트가 결정된다.
- 우리가 step3에서 적용했던 템플릿 메서드는 커넥션을 어떻게 만드는지 알수 없고 오직 그 커넥션을 사용하기만한다.
- 이 방법이 대표적인 제어의 역전이다.

#### 프레임워크와 라이브러리
- 프레임워크도 제어의 역전 개념이 적용된 대표적인 기술로 라이브러리와 차이가 존재한다.
- 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션의 흐름을 직접 제어한다. 단지 동작 중에 필요한 기능을 위해 능동적으로 라이브러리를 사용할 뿐이다.
- 허나 프레임워크는 반대로 애플리케이션 코드가 프레임워크에 의해 사용된다.
- 프레임워크 위에 개발한 클래스를 등록하고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.
- 이를 통해 프레임워크는 분명한 제어의 역전 개념이 적용되어야 한다는 것을 알 수 있다.
- IoC를 적용하면 설계가 깔끔해지고 유연성이 증가하며 확장성이 좋아진다.

> - 현재 우리도 UsreDao, Connection을 생성하는 것을 Factory가 담당하고 있다.
> - 이를 통해 UserDao는 수동적인 존재가 되었고 UserDaoTest는 Factory가 만들어주는 Dao, Connection을 사용해야 한다.
> - Factory를 도입한 이러한 과정이 IoC를 적용한 과정이라고 할 수 있다.

---

## 1.5 스프링의 IoC
### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC
- 스프링이 제어권을 가지고 있는 오브젝트를 '빈' 이라고 한다.
- 빈은 보통 **빈 팩토리에서** 관리되고 이를 더 확장한 **애플리케이션 컨텍스트에서** 주로 사용한다.
- 우리가 만들었던 DaoFactory를 스프링 빈 팩토리가 사용할 수 있는 설정정보로 만들 수 있다.

#### [7) step7](./step7)
- 스프링 의존성을 추가하고 Factory의 객체들을 빈으로 등록해주었다.
- test에서는 해당 빈정보를 통해 객체를 가져와 테스트를 진행할 수 있다.
- 현재는 굳이 메서드가 하난데 이렇게 귀찮게 해야하나 싶겠지만 구성을 다르게하는 메소드들을 추가하면 빈으로 등록된 객체를 간단하게 가져올 수 있다.
- 예를들어 getBean("myDao", UserDao.class)이런 식으로 말이다.
- 게다가 빈으로 등록하면 스프링에서는 매우 유용하면서도 방대한 기능들을 제공해준다.

### 1.5.2 애플리케이션 컨텍스트 동작방식
- 우리가 만들었던 팩토리에 대응되는 것이 스프링 ApplicationContext이다.
- 이를 Ioc Container, Spring Container등 다양하게 부른다.

#### 동작방식
![img](./step7/applicationContext.png)
- 클라이언트는 userDao를 요청하면 ApplicationContext는 빈으로 등록엔 UserDao를 확인하고 해당 UserDao를 생성하여 전달해준다.

#### ApplicationContext를 사용했을 때 얻는 장점
1. 클라이언트는 구체적인 팩토리 클래스를 알 필요 없다.
   - 오직 ApplicationContext하나로 빈으로 등록된 클래스들을 사용할 수 있다.
2. IoC서비스를 제공해준다.
    - 객체를 생성해주는 것 뿐만아니라 수많은 필요한 관계설정 생명주기 관리등 다양한 효과를 누릴 수 있다.
3. 빈을 검색하는 다양한 방법을 제공한다.

---

## 1.6 싱글톤 레지스트리와 오브젝트 스코프
- step7에서 똑같은 두개의 Dao를 ApplicationContext에서 가져왔을 때 같은 참조를 하고 있는것을 알 수 있다.
- 보통 동일성은 ==, 동등성은 equals비교를 통해 보장해준다.
- ApplicationContext는 빈을 디폴트 설정일 경우 싱글톤 객체로 생성하므로 동일성을 보장해준다.
- 동등성은 객체가 따로 equals를 오버라이딩하지 않았다면 Object의 equals를 사용하는데 이는 동일성 비교를 하는것을 알 수 있다.
- 여기서 싱글톤은 디자인 패턴에 나오는 싱글톤 패턴과 비슷하지만 구현 방법은 확연히 다르다.

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
**서버 애플리케이션과 싱글톤**
- 스프링은 보통 자바 엔터프라이즈 기술을 사용하는 **서버환경에서** 주로 사용된다.
- 스프링은 대규모 엔터프라이즈 서버환경에서 요구되는 환경을 위해 설계되었기 때문에 초당 수십 수백번의 요청이 들어오는 트래픽을 견뎌야한다.
- 매번 요청이 올때마다 객체를 생성하면 JVM이 감당할 수 없을 것이다.
- 그래서 엔터프라이즈 분야에서는 **서비스 오브젝트라는** 개념을 사용해왔는데 서블릿은 자바 엔터프라이즈 기술의 가장 기본이되는 서비스 오브젝트라고 할 수 있다.
- 서블릿은 보통 멀티스레드 환경에서 **싱글톤으로** 동작한다. 서버 환경에서는 환경에 맞게 **서비스 싱글톤 사용을 권장한다**.
- 하지만 디자인 패턴 관점에서는 싱글톤 패턴이 안티패턴이라고도 불리운다.

#### 싱글톤 패턴의 한계
- private 생성자를 갖고 있기 때문에 상속할 수 없고 static field를 사용해 객체지향적인 특성을 누릴 수 없다.
- 싱글톤은 만들어지는 방법이 제한적이므로 목 객체를 이용해 대체하기도 쉽지않아 테스트하기 어려운 코드를 만든다.
- 서버환경에서는 여러개의 JVM이 분산돼서 설치되어있다면 싱글톤이 하나만 생성되는 것을 보장하지 못한다.
- 싱글톤은 전역 상태이므로 어디서든 만들어 질 수 있어 위험하다.

#### 싱글톤 레지스트리
- 서버환경에서는 싱글톤 서비스 오브젝트 방식을 사용하는 것을 적극 지지하지만 자바의 기본적인 싱글톤 구현방식은 한계점이 많이 존재한다.
- 그렇기 때문에 스프링이 직접 싱글톤 객체를 만들고 관리하는 기능을 제공하는데 이를 **싱글톤 레지스트리라고 한다**
- 스프링 컨테이너는 싱글톤의 전체적인 주기를 관리하므로 싱글톤 관리 컨테이너이기도 하다.
- 싱글톤 레지스트리의 장점은 private, statis field등을 사용하지 않아도 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.
- 그렇기 때문에 빈으로 등록된 객체는 public 생성자를 사용하더라도 스프링은 객체의 생성에 관한 모든 권한을 ApplicationContext가 가지고 있기 때문에 싱글톤 객체를 제공해줄 수 있다.
- 이는 싱글톤으로 사용해야할 환경이 아니라면 일반 오브젝트로 만들 수 있기 때문에 목 객체를 활용한 테스트도 간편해진다.

> 즉 스프링은 IoC컨테이너일 뿐만아니라, 고전적인 싱글톤 패턴의 한계를 대신해서 싱근톤을 만들고 관리해주는 싱글톤 레지스트리이다.

### 1.6.2 싱글톤과 오브젝트 상태
- 멀티스레드 환경에서 서비스 오브젝트 형태로 사용하는 싱글톤은 stateless(무상태) 방식으로 만들어져야 한다.
- stateful(상태유지) 방식으로 만들면 동기화 문제가 일어나기 십상이다.
- 무상태 방식을 만들기 위해서는 메서드의 독립적인 스코프를 활용하면 멀티 스레드환경에서 동기화 문제를 해결할 수 있다.

### 1.6.3 스프링 빈의 스코프
- 보통 싱글톤으로 사용되지만 매번 새로운 객체를 만드는 **프로토 타입** 스코프가 존재한다.
- 그리고 매 요청때마다 생기는 **Request Scope**, 웹의 세션과 스코프가 유사한 **Session Scope** 등도 존재한다.

---

## 1.7 의존관게 주입(DI)
### 1.7.1 제어의 역전과 의존관계 주입
- DaoFactory처럼 객체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화한 것이 IoC 컨테이너이다.
- 여기서 IoC라는 용어는 폭넓은 의미로 사용되어 명확하게 설명하기 어렵다.
- 스프링이 서블릿 컨테이너처럼 서버에도 동작하는 서비스 컨테이너인지, 아니면 단순히 IoC 개념이 적용된 템플릿 메서드 패턴을 이용해 만들어진 프레임워크인지 명확하게 말하기 어렵다.
- 그러하여 스프링이 제공하는 IoC방식의 핵심을 짚어주는 의존관계주입(DI)라는, 좀 더 의도가 명확히 들어나는 이름을 사용하기 시작한 것이다.
- **스프링 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 부른다**
- 그래서 초기에는 주로 IoC 컨테이너라고 불리던 스프링이 지금은 의존관계 주입 컨테이너, 혹은 DI 컨테이너라고 더 많이 불리운다.

> DI(의존관계 주입)은 외부로부터 객체의 참조를 제공받고 이를 통해 동적으로 의존관계를 형성하는 방법이다.

### 1.7.2 런타임 의존관계 설정
- UserDao는 ConnectionMaker라는 interface에게 의존하고 있다.
- 이렇게 인터페이스에 대해서만 의존하고있으면 의존관계가 느슨해지면서 변화에 영향을 덜 받는 상태가 되기때문에 결합도를 낮출 수 있다.
- 이러한 의존관계는 설계 모델 관점에서의 의존관계이다.
- **런타임 의존관게는 설계 모델 관점의 의존관계와는 다르다.**

> - 인터페이스를 통해 설계 시점에 느슨한 의존관게를 갖는 경우 UserDao의 오브젝트가 런타임시에 사용할 오브젝트가 어떤 클래스로 만든것인지 미리 알 수가 없다.
> - 프로그램이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임시에 의존관계를 맺는 대상, 즉 실제 사용대상을 **의존 오브젝트(dependent Object)라고 한다.**

- **의존관계 주입은** 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주체를 런타임시에 연결해주는 역할을 한다.
- 정리하면 의존관계 주입은 3가지 조건을 만족하는 작업을 의미한다.

**의존관계 주입의 3가지 조건**
- 인터페이스에만 의존할 경우 클래스 모델이나 코드에는 런타임 시점에 의존관계가 드러나지 않는다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재에서 결정한다.
- 의존관계는 사용할 오브젝트에 대한 참조를 외부에서 주입해 줌으로써 만들어진다.

> 스프링에서는 보통 제3의 존재는 IoC 컨테이너, 빈팩토리라고 볼 수 있다.

### 1.7.3 의존관계 검색과 주입
- 스프링이 제공하는 IoC방법에는 의존관계 주입 뿐만아니라 스스로 검색을 이용해 의존관계를 찾는 **의존관계 검색도** 존재한다.
- 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.
- 물론 자신이 어떤 클래스의 오브젝트를 사용할지는 결정하지 않는다.(그러면 IoC라고할 수 없기 때문이다.)


### [8) step8](./step8)
- 의존관계 검색을 통해 UserDao를 구현하였다.
- UserDao 생성자를 보면 의존관계를 주입받지 않고 ApplicationContext에서 빈으로 등록된 ConnectionMaker를 찾아서 의존관계를 설정한다.
- IoC 원칙에도 잘 들어 맞기 때문에 IoC가 적용된 것을 알 수 있다.
- 하지만 의존관계 주입에 비해 UserDao에 스프링 API가 나타난다.
- 그러므로 보통 의존관계 주입 방식을 사용하는 편이 낫다.
- 의존관계 검색이 필요한 시점이 딱 하나 존재하는데 애플리케이션 기동 시점이다.
- main() 메서드 안에서는 DI를 이용해 주입받을 방법이 없으므로 의존관계 검색을 이용해야 한다.
- main 메서드와 비슷한 역할을 하는 서블릿에서 스프링 컨테이너를 사용하려면 한 번은 의존관계 검색을 하여야 하는데 이는 스프링이 제공해주므로 직접 구현할 필요가 없다.

#### DI(의존관계 주입), DL(의존관계 검색)의 차이점
- DL은 DI에 비해 검색하는 객체(UserDao)는 빈으로 등록할 필요가 없다.
- DI는 UserDao도 빈으로 등록되어야 한다. 왜냐하면 UserDao에 ConnectionMaker 오브젝트를 주입해주려면 UserDao에 대한 생성과 초기화 권한을 갖고 있어야 한다.
- 그렇기 위해선 UserDao도 IoC방식으로 컨테이너에서 생성되는 오브젝트, 즉 빈이어야 하기 때문이다.

#### DI 받는다
- 주입하는 대상이 인터페이스가 아닌 특정 클래스에 고정되어 있다면 DI가 일어날 수 없다.
- DI에서 말하는 주입은 동적으로 구현 클래스를 결정해서 제공할 수 있어야 한다.
- 이는 단순한 오브젝트 주입에서 조금 더 추상화된 개념이라고 할 수 있다.

### DI의 이점
#### 1) 기능 구현의 교환
- 현재는 MysqlConnectionMaker로 connectionMaker를 빈을 등록하였다.
- 만약 step1의 초난감 Dao에서는 connectionMaker의 구현체를 바꾸려면 하나하나 직접 변경해주어야 한다.
- DI를 적용한 step7의 경우에는 빈으로 등록한 connectionMaker의 구현체만 변경해주면 된다.

#### 2) 부가기능 추가 [Step 9](./step9)
- DB의 커넥션 수를 카운트하고 싶다고 해보자.
- 초난감 Dao에서는 UserDao 코드를 수정하여서 기능을 구현해야한다.
- 커넥션 수를 카운팅하는 것은 UserDao이 관심사항이 아니다.
- DI 컨테이너에서는 간단하게 DI를 응용해서 구현할 수 있다.
- CountingConnectionMaker를 만들고 이를 빈으로 등록시켜 주면된다.
- CountingConnectionMaker에는 멤버변수로 ConnectionMaker를 가지고 있다.
- CountingConnectionMaker의 makeNewConnection이 호출될 때 커넥션 수를 카운트하고 멤버변수로 가지는 CoonectioMaker의 makeNewConnection을 반환해주면 된다.

### 1.7.5 메서드를 이용한 의존관계 주입
- 지금까지는 생성자를 통해 DI를 적용했지만 생성자 이외에도 setter 메서드혹은 직접 정의한 메서드로 DI를 적용시킬 수 있다.
- setter 메서드는 IDE가 만들어주는 관례를 따르는게 편리하다.
- [step 10](./step10)은 setter 메서드를 통해 DI를 적용 시킨 예이다.
- UserDao를 빈으로 등록할 때 따로 setter를 해주는 것을 까먹으면 안된다.

---

## 1.8 XML을 이용한 설정
- DaoFactory를 보면 대부분 틀에 박힌 구조가 반복된다.
- 이러한 빈 정보 등록은 XML로도 간편히 할 수 있다.
- 자바빈 관례를 따라 수정자 메서드는 프로퍼티가 되며 프로퍼티 이름을 set을 제외한 나머지 부분을 사용한다.

```XML
<beans>
    <bean id="connectionMaker" class="ch1.step4.MysqlConnectionMaker"/>

    <bean id="userDao" class="ch1.step4.UserDao">
        <property name="connectionMaker" ref="connectionMaker"/>
    </bean>
</beans>
```
- xml로 빈을 등록한 예시이다.
- id는 Factory에서 method name으로 매칭하면 된다.
- class는 실제 리턴할때 생성되는 클래스이다.(리턴 타입이 아니다!)
- connectionMaker의 경우 따로 다른 의존 객체가 존재하지 않으므로 프로퍼티 설정이 필요없다.
- userDao의 경우 setter로 주입할 때 위와같이 name에는 프로퍼티 name을 사용하고 ref에는 의존성을 주입할 빈을 적으면 된다.

### DTD와 스키마
- XML문서는 미리 정해진 구조를 따라 작성되었는지 DTD와 스키마를 통해 검사가 가능하다.

```XML
<!DOCTYPE beans PUBLIC "~~~~~">
-> DTD선언은 이런식으로 할 수 있다.

<beans xmls="http://www.springframework.org/xhema/beans">
</beans>
-> 가능하면 스키마를 사용하는게 더 좋다.
```

#### [11) step11](step11/applicationContext.xml)
- xml로 빈으로 등록하여도 정상적으로 동작하느 것을 알 수 있다.

### 1.8.3 DataSource 인터페이스로 변환
- ConnectionMaker는 단순히 DB커넥션만 생성해주는 인터페이스이다.
- 자바에서는 이를 추상화한 DataSource를 제공해준다.
- ConnectionMaker가 아닌 DataSource를 사용하도록 Dao를 수정해보자.
- DataSource구현체들을 사용하기 위해 JDBC 의존성을 추가한다.

### [12) step12](step12)
- DataSource를 자바코드로 빈으로 등록할 수도 있다.
- 그리고 xml로도 설정이 가능하다.
- DataSource를 빈으로 등록한 자바코드를 보면 여러가지 커넥션 정보를 넣는다.
- xml에서는 프로퍼티로 값을 등록하면 빈이 아닌 단순 정보도 초기화하는 과정에 수정자 메서드에 넣을 수 있다.

---

## 1.9 정리
### 알아본 개념들
- 관심사의 분리, 리팩토링
- 전략패턴
- 개방 폐쇠 원칙
- 낮은 결합도와 높은 응집도
- 제어의 역전 / Ioc
- 싱글톤 레지스트리
- DI 컨테이너와 의존관계 주입(DI)
- 생성자, 수정자(setter) 주입
- XML 설정
