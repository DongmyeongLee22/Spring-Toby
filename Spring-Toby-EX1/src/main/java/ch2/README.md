# Chapter 2: 테스트
- 스프링이 가장 강조하고 가치있게 두고 있는 것중 하나는 테스트이다.
- 애플리케이션은 계속 변화하고 복잡해져간다. 그 변화에 대응하는 첫번째 전략이 확장과 변화를 고려한 **객체지향적 설계와** 그것을 효율적으로 담을 수 있는 **IoC / DI** 같은 기술이라면, 두번째 전략은 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 **테스트 기술이다.**

> 테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.

### 2.1 UserDaoTest 다시 보기

#### 작은 단위의 테스트
- 테스트하고자 하는 대상이 장황하다면 오류가 발생하였을 때 문제지점을 찾기가 힘들다.
- 테스트는 가능하면 작은 단위로 쪼개서 하나의 기능에 대한 테스트를 하도록 설계하여야 한다.
- 이 또한 관심사의 분리가 적용되는 한 예라고 할 수 있다.
- 이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 **단위 테스트** 라고 한다.

#### UserDaoTest는 단위 테스트 일까?
- UserDaoTest는 단위 테스트라고할 수 있을까?
- UserDaoTest는 DB를 사용하지만 수행할 때 매번 User의 테이블을 제거하고 테스트하였기 때문에 DB의 상태를 관장하고 있으므로 단위 테스트라고 할 수 있다.
- 만약 테스트를 위해 DB를 특정 상태로 만들 수 없다면 이는 단위테스트라고 할 수 없다.
- 그리고 이렇게 작은 단위의 테스트는 주로 개발자가 만든 코드를 스스로 확인하는 과정이므로 개발자 테스트, 프로그래머 테스트라고 부른다.

#### UserDaoTest의 문제점
- 현재 UserDaoTest의 결과는 출력을 통해 수동 확인을 하여야한다.
- main()메서드를 하나하나 직접 실행해야하므로 번거롭다.

---

### 2.2 UserDaoTest 개선, 2.3 개발자를 위한 테스팅 프레임워크 JUnit
> 사용법에 대한 설명은 블로그에 이미 다 정리했으니 생략하며 JUnit5로 구현하자!

#### JUnit 테스트로 전환([step 1](../../../test/java/ch2/step1/UserDaoTest.java))
- 해당 테스트는 항상 동일한 결과를 보장한다.

#### 포괄적인 테스트
- getCount()는 현재 0, 1인 상태만 테스트하고 있다.
- 이는 해당 기능이 완벽하다고 확신할 수 있을까?
- 문제가 있는 코드인데 테스트가 성공하는건 매우 위험하다.
- 그러므로 꼼꼼히 테스트하는 것은 좋은 자세이다.
- step1의 getcount( ) 테스트 참고

#### addAndGet() 보완
- 하나의 유저만 추가하고 get하는 것은 제대로된 동작을 보장하기 어렵다.
- 그러므로 여러 유저를 추가하고 테스트를 진행하는게 더 꼼꼼하게 테스트할 수 있다.
- step1의 addAndGet_upgrade( ) 테스트 참고

#### get() 예외조건 테스트([step 2](../../../test/java/ch2/step2/UserDaoTestStep2.java))
- User가 아닌 회원을 조회하면 어떻게 될까?
- 현재는 get()메서드에서 아무처리도하지 않았기 때문에 SQL예외가 발생한다.
- null값으로 처리하거나, 따로 예외를 직접 던져주는것이 바람직하다.
- 우선 테스트를 진행하고 해당 테스트가 성공하도록 UserDao를 변경해보자!

#### 포괄적인 테스트
- 개발자가 테스트를 만들 때 자주하는 실수가 하나있다.
- 바로 성공하는 테스트만 골라서 만드는 것이다.
- 테스트를 작성할 때 자기도 모르게 문제가 될 상황들을 피해서 작성하는 경향이 있다.
- 스프링의 창시자 로드 존슨은 **항상 네거티브 테스트를 먼저 만들라.** 라고 조언을 하였다.

#### 테스트가 이끄는 개발
**기능 설계를 위한 테스트**
- 잘 작성된 코드는 하나의 기능정의서처럼 보일 수 있다.
- 흔히 행위 주도 개발의 순서인 given, when, then처럼 말이다.
- 그리고 get() 예외 조건 테스트는 테스트를 만들고 해당 테스트가 성공할 수 있게 기능을 구현하였다.
- 이러한 방법을 사용하면 테스트가 성공할 때 코드 구현과, 테스트라는 작업을 동시에 끝마칠 수 있게 된다.

**테스트 주도 개발**
- 테스트주도개발은 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 작성하고, 테스트를 성공하게 해주는 코드를 작성하는 개발방법이다.
- 이는 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법이라고 볼 수 있다.
- 그리고 개발을 하다보면 기능을 빨리 구현하고 싶어서 테스트 만들기가 귀찮아지는 경향이 있는데 테스트를 먼저 작성하고 그 테스트를 성공하도록 하면 꼼꼼하게 테스트를 작성할 수 있다.

> 스프링은 테스트하기 편리한 구조의 애플리케이션을 만들게 도와주므로 개발자들은 스프링이 제공해주는 많은 기능을 통해 테스트를 작성하면 빠르고 간편하게 테스트를 작성할 수 있다.

- JUit은 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 테스트 오브젝트를 만들어 테스트를 진행한다.

**픽스처**
- 테스트를 수행하는 데 필요한 정보나 오브젝트를 **픽스처라고** 한다.
- 보통 이는 @BeforeEach 메서드에 정의하는것이 편리하다.
- UserDaoTest에서 UserDao를 픽스처라고 할 수 있다.

---

### 2.4 스프링 테스트 적용([step 3](../../../test/java/ch2/step3/UserDaoTestStep3.java))
- 테스트는 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어서 사용하는것이 원칙이다.
- 하지만 애플리케이션 컨텍스트 처럼 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만드는 것이 좋다.
- 빈으로 등록된 객체를 싱글톤이기때문에 전체가 공유하는 오브젝트를 적용하여도 무방하다.
- 스프링 테스트의존성을 추가하고 @ContextConfiguration을 통해 빈으로 등록 정보를 추가할 수 있다.
- 그리고 JUnit5에서는 @ExtendWith(SpringExtension.class)를 추가해주어야 ApplicationContext를 사용할 수 있다.
- 마지막으로 ContextConfiguration를 여러 클래스에 걸쳐 공통으로 사용하더라도 전체 테스트에서는 하나의 ApplicationContext로 만들어져 사용된다.

> ApplicationContext가 @Autowired되는 이유는 ApplicationContext는 초기화시 자기 자신도 빈으로 등록하기 때문이다.

#### 2.4.2 DI와 테스트
- UserDao와 DB 커넥션 생성 클래스 사이에는 DataSource라는 인터페이스를 두었다.
- DI를 통해 주입받으므로 어떤 구현체가 사용되는지 UserDao는 알 필요 없다.
- 만약 절대로 커넥션의 구현체를 바꾸지 않는다고 할 때에도 이 의존성 주입을 사용해야할까?
- 그래도 사용하는것이 좋은데 그 이유에 대해 알아보자.

**그래도 DI를 사용해야하는 이유**
- 소프트웨어 개발에서는 절대 바뀌지 않는것은 존재하지 않는다.
- 클래스의 구현방식이 변경되지 않는다고 해도 DI를 적용해두면 다른 차원의 서비스 기능을 도입할 수 있다.
  - 1장에서 DB커넥션 수를 세는 카운팅 기능을 추가할 때 DI가 없었더라면 Dao를 수정해야 했을 것이다.
- DI를 이용하므로 목 객체를 통한 단위 테스트가 용이해진다.

**테스트 코드에 의한 DI**
- 만약 빈으로 등록된 디비 정보가 아닌 새로운 정보를 사용하고 싶을 때 테스트 코드에서 의존관계 주입을 할 수 있다.
- 하지만 ApplicationContext는 모든 테스트에서 공유하므로 다른 테스트에도 영향을 끼친다.
- 이를 해결하기 위해선 test용 config 파일을 생성하여 그 config 파일을 사용하면 된다.

**컨테이너 없이 DI**
- 물론 UserDao 객체를 ApplicationContext가 아닌 직접 생성할 수 있다.
- 직접 DataSource객체를 만들고 UserDao를 생성할 때 주입해주면된다.
- 즉 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐 컨테이너만이 오직 DI를 할 수 있는것은 아니다.

> **침투적 기술과 비침투적 기술**
> - 침투적 기술은 기술을 적용했을 때 애플리케이션 코드에 기술 관련 API가 등장하거나, 특정 인터페이스, 클래스를 사용하도록 강제하는 것이다.
> - 이는 애플리케이션 코드가 특정 기술에 종속됨을 말해준다.
> - 비침투적 기술은 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용이 가능하다.
> - 따라서 기술에 종속적이지 않는 순순한 코드를 유지할 수 있게 해준다.
> - 스프링은 이런 **비침투적 기술의** 대표직인 예이다.
> - 그렇기 때문에 컨테이너 없이 DI를 적용할 수 있는 것이다.

**어떤 DI를 선택해야할까?**
- 위에서 본 세가지 방법은 상황에 맞게 쓸 수 있다.
- 테스트를 위해 객체 초기화가 간단하다면 항상 스프링 컨테이너 없이 테스트 할 수 있는 방법을 우선적으로 고려하자. 이 방법이 가장 빠르고 테스트가 간결할 것이기 때문이다.
- 여러 객체들간의 복잡한 의존관계가 있을 경우는 스프링의 도움을 받자.

---

### 2.5 학습테스트로 배우는 스프링
- 프레임워크나 라이브러리의 기능에 대해 테스트하는 것을 학습 테스트라고한다.
- 학습 테스트의 목적은 자신이 사용할 API나 프레음워크의 기능을 테스트 해보면서 사용 방법을 익히려는 것이다.
- 따라서 테스트이지만 검증의 목적이 아닌 자신이 테스트를 만드려고 하는 기술이나 기능에 대해 얼마나 제대로 이해하고 있는지 검증하기 위함이다.
- 또 테스트 코드를 작성해보면서 빠르고 정확하게 테스트 사용법을 익힐 수 있다.

#### 2.5.1 학습테스트의 장점
- 다양한 조건에 따른 기능을 손쉽게 확인할 수 있다.
- 학습 테스트 코드를 개발 중에 참고할 수 있다.
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
- 테스트 작성에 대한 좋은 훈련이 된다.
- 새로운 기술을 공부하는 과정이 즐거워 진다.

> 스프링은 꼼꼼하게 테스트를 만들어가며 개발해온 프레임워크이다. 거의 모든 기능에 대해 방대한 양의 테스트가 만들어져 있다. 스프링 배포판의 압축을 풀어보면 소스코드와 테스트 코드를 볼 수 있다.

#### 2.5.2 학습 테스트 예
**JUnit 테스트 오브젝트 테스트**
- 과연 JUnit은 테스트 메서드 수행마다 새로운 오브젝트를 만들까?
- [JUnitTest](../../../test/java/ch2/step4/JUnitTest.java)

**스프링 테스트 컨텍스트 테스트**
- ApplicationContext는 테스트 개수에 상관없이 정말 한개만 만들어질까?
- [ApplicationContextTest](../../../test/java/ch2/step4/ApplicationContextTest.java)

#### 2.5.3 버그 테스트
- 버그 테스트란 코드에 오류가 있을 때 그 오류를 가장 잘 드러낼 수 있는 테스트이다.
- 어떤 기능에 오류가 발견하였을 때 무턱대고 코드를 뒤져가면서 수정하기보다 버그 테스트를 만들어보는 편이 유용하다.
- 버그 테스트는 일단 버그가 원인이 되어서 실패하는 테스트로 만들어야 한다.
- **버그 테스트의 필요성과 장점**
  - 테스트의 완성도를 높여준다.(비슷한 문제가 발생하면 테스트로 인해 쉽게 추적가능)
  - 버그의 내용을 명확하게 분석해준다.(테스트 작성을 통해 분석해볼 기회가 생김)
  - 기술적인 문제를 해결하는데 도움이된다.
