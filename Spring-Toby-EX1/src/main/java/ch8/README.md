# Chapter8. 스프링이란 무엇인가?
- 스프링은 단순히 IoC/DI를 편하게 적용하도록 돕는 단계를 넘어 엔터프라이즈 애플리케이션 개발의 전 영역에 걸쳐 다양한 종류의 기술에 관여한다.
- 스프링의 사상과 가치, 그리고 적용된 원칙을 좀 더 깊이 있게 생각해보자.
- 그 과정을 통해 스프링이란 도대체 무엇이고 왜 존재하는지를 좀 더 체계적으로 이해할 수 있다.

## 8.1 스프링의 정의
- 스프링의 가장 잘 알려진 정의는 **자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크이다.**

#### 애플리케이션 프레임워크
- 프레임워크나 라이브러리는 특정 업무 분야 한 가지 기술에 특화된 목표를 가지고 만들어진다.
- 웹 계층을 MVC구조로 쉽게 만들 수 있도록 해주거나, 관계형 DB를 객체로 매핑해주는 ORM 기술등을 예로 들 수 있다.
- 그래서 프레임워크는 애플리케이션의 특정 계층에서 주로 동작하는 한 가지 기술 분야에 집중된다.
- 하지만 스프링은 이와 다르기 **애플리케이션 프레임워크라는 특징을 갖는다.**
- 애플리케이션 프레임워크는 특정 계층이나, 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크를 말한다.
- 애플리케이션 프레임워크는 애플리케이션 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는 데 일차적인 목표를 두는 프레임워크이다.
- 스프링을 MVC 프레임워크, JDBC/ORM 자원 프레임워크라고 생각하는 것은 스프링의 일부일 뿐이다.
- **스프링의 일차적인 존재 목적은 핵심 기술에 담긴 프로그래밍 모델을 일관되게 적용해서 엔터프라이즈 애플리케이션 전 계층과 전 영역에 전략과 그 기능을 제공해줌으로써 애플리케이션을 편리하게 개발해주는 애플리케이션 프레임워크로 사용되는 것임을 기억하자**

#### 경량급
- 스프링에서 의미하는 경량급은 스프링 자체가 아주 가볍다거나 작은 규모의 코드로 이뤄졌다는 뜻은 아니다.
- 오히려 스프링은 매우 복잡하고 방대한 프레임워크이다.
- 경량급이라는 의미는 **불필요하게 무겁지 않다는 의미이다.**
- 불필요하게 무겁던 EJB는 동작하기위해 고가의 장비들이 필요했지만 스프링은 그렇지 않았다.

#### 자바 엔터프라이즈 개발을 편하게
- 스프링은 근본적인 부분에서 엔터프라이즈 개발의 복잡함을 제거해내고 진정으로 개발을 편하게 해주는 해결책을 제시한다.
- 단순히 편리한 몇 가지 도구나 기능을 제공해주는 차원이아닌 엔터프라이즈 개발의 근본적인 문제점에 도전해 해결책을 제시한다는 것이 기존의 기술과 스프링의 접근방법의 차이점이다.
- **편리한 애플리케이션 개발이란 로우레벨 기술에 신경쓰지 않고 애플리케이션의 핵심사항인 사용자의 요구사항, 비즈니스 로직에만 집중할 수 있는 개발이라고 할 수 있을 것이다.** 
- EJB는 이러한 편리한 애플리케이션 개발을 하기위해 다른 차원의 더 큰 복잡함을 애플리케이션 개발에 끌고 들어왔지만 스프링은 동일하게 애플리케이션 개발을 편리하게 해주지만 다른 차원의 애플리케이션을 끌고올 필요 없이 스프링의 기본 기술로 이를 지원한다.

> 스프링은 오픈소스의 장점을 충분히 취하면서 동시에 오픈소스 제품의 단점과 한계를 잘 극복하고 있는, 전문적이고 성공적인 오픈소스 소프트웨어이다.
---

## 8.2 스프링의 목적
- 모든기술이나 지식이 그렇지만, 스프링은 더더욱 그 목표를 분명히 알고 사용하지 않으면 그 가치를 제대로 얻기 힘들다.
- 어떤 기술이든 그 자체는 도구로 불가하다. **그것을 용도에 맞게 잘 활용해서 궁극적으로 이루고자 하는 목표를 이루는 것이 중요하지, 도구의 사용법만 열심히 익힌다고 결과를 저절로 얻을 수 있는 것은 아니다.**

### 8.2.1 엔터프라이즈 개발의 복잡함
- 2000년대 초반에 자바 엔터프라이즈 프로젝트가 실패하는 이유들에 대해 논의할 때 대부분은 엔터프라이즈 시스템 개발이 너무 복잡해져서 였다.

#### 복잡함의 근본적인 이유
- **기술적인 제약조건과 요구사항이 계속해서 늘어남**
  - 엔터프라이즈 시스템이란 서버에서 동작하며 기업과 조직의 업무를 처리해주는 시스템을 말한다.
  - 엔터프라이즈 시스템은 많은 사용자의 요청을 동시에 처리해야 하므로 서버의 자원을 효율적으로 공유하고 분배해서 사용할 수 있어야 한다.
  - 또한 기업의 중요한 정보를 위해 보안성과 안전성도 뛰어나야 한다.
  - 따라서 뛰어난 성능과 서비스의 안전성이 요구를 고려한 개발 기술이 필요하므로 주 비즈니스 로직외에 구현해야할 기술들이 많다는 뜻이다.
- **엔터프라이즈 애플리케이션이 구현해야 할 핵심기능인 비즈니스 로직의 복합함의 증가**
  - 시간이 갈수록 엔터프라이즈 시스템을 이용해 기업의 핵심 업무를 처리하는 비율이 늘어났고, 점차 대부분의 업무 처리는 컴퓨터를 이용하여 처리된다.
  - 그 만큼 엔터프라이즈 시스템에 대한 업무 의존도가 높아져 비즈니스 로직의 복잡함이 증가하였따.
- 2000년 전후의 경제위기로 인해 업계의 업무 프로세스를 변경하고 조종하는 속도가 빨라졌고 이는 엔터프라이즈 시스템의 변경이 요구된다.
- 변경이 있을 때 마다 이를 잘 변경할 수 있도록 유지보수성, 추가 개발등의 작업에 대한 부담감은 계속 커지면서 개발의 난이도가 증가되었다.

#### 복잡함을 가중시키는 원인
- **가장 큰 원인은 근본적인 비즈니스 로직과 엔터프라이즈 기술이라는 두 가지 복잠한이 한데 얽혀 있기 때문이다.**
- 하나씩만 놓고봐도 복잡한것을 한 번에 다루니 당연한 결과다.

### 8.2.2 복잡함을 해결하려는 도전
#### 제거될 수 없는 근본적인 복잡함
- 엔터프라이즈 개발의 근본적인 복잡함의 원인은 제거할 대상이아니다.
- 기술적인 복잡함을 해결하고자 보안을 취약하게 하거나, 사용자가 늘어나더라도 확장이 불가능한 시스템을 만들 수는 없다.
- 복잡함을 제거하는게 아닌 그 복잡함을 효과적으로 상대할 수 있는 전략과 기법이 필요하다.
- 가장 먼저 할 일은 성격이 다른 두가지 복잡함을 분리하는 것이다.

#### 실패한 해결책: EJB
- EJB의 기본전략도 이 두가지의 종류의 복잡함을 분리하는 것이었다.
- 하지만 그런 목표를 달성하는데 실패하였다. EJB는 기술적인 복잡함을 애플리케이션 핵심 로직에서 일부분 분리하는데는 성공했다.
- 허나 EJB환경에서 동작하기 위해 특정 인터페이스를 구현하고, 특정 클래스를 상속하고, 서버에 종속적인 서비스를 통해서만 접근하고 사용이 가능하게 만드는 등의 EJB 개발 방식이 잘못된 선택이었다.
- 결국 EJB는 기술적인 복잡함을 덜기 위해 오히려 더 큰 복잡함을 추가하는 실수를 범했다.
- EJB라는 틀 안에서 자바 코드를 만들게 강제하여 자바 언어의 장점을 살릴 수가 없었다. 특정 클래스를 상속하게 해서 더 이상 상속구조를 갖지 못하게 만들었다.

#### 비침투적인 방식을 통한 효과적인 해결책: 스프링
- 스프링은 EJB의 실패를 교훈으로 삼아서 출발했다. EJB의 처음 목표와 마찬가지로 기술적인 복잡함을 애플리케이션 핵심 로직의 복잡함에서 제거하는데 목표를 뒀다.
- 하지만 EJB처럼 어떤 기술을 적용했을 때 그 기술과 관련된 코드나 규약 등이 코드에 등장하는 **침투적인 기술이 아닌** 기술 적용 사실이 코드에 반영되지 않는 **비침투적인 기술을 적용했다.**
- 이를 통해 스프링은 기술적인 복잡함과 비즈니스로직을 다루는 코드를 깔끔하게 분리하는 과정에서 스프링 스스로가 애플리케이션 코드에 불필요하게 나타나지 않도록 하였다.
- 스프링을 적용한다고 근본적인 복잡함의 원인이 사라진건 아니지만 스프링을 통해 성격이 다른 복잡함들을 깔끔하게 분리해줬기 때문에 효과적으로 그에 대응할 수 있는 기반이 마련된 것이다.

### 8.2.3 복잡함을 상대하는 스프링의 전략
- 스프링의 기본적인 전략은 비즈니스 로직을 담은 애플리케이션 코드와 엔터프라이즈 기술을 처리하는 코드를 분리시키는 것이다.

#### 기술적 복잡함을 상대하는 전략
- 기술적인 복잡함을 분리해서 생각하면 그것을 효과적으로 상대할 수 있는 적절한 전략을 발견할 수 있다.
- 스프링은 엔터프라이즈 기술을 적용했을 때 발생하는 복잡함의 문제를 두 가지로 분류하고 각각에 대한 적절한 대응방법을 제공한다.

**첫 번째 문제: 기술에 대한 접근 방식이 일관성이 없고, 특정환경에 종속적이다.**
- 일관성 없고 특정환경에 종속적인거에 대비하기 위해 스프링은 서비스 추상화를 제공한다.
- 추상화를 통해 로우레벨의 기술 구현 부분과 기술을 사용하는 인터페이스를 분리하고, 환경과 세부 기술에 독립적인 접근 인터페이스를 제공하는 것이 가장 좋은 해결책이다.

**두 번째 문제: 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다.**
- 트랜잭션이 비즈니스 로직과 함께나타나는 것을 예로들 수 있다.
- 스프링은 성격이 다른 코드가 섞여서 등장하는것을 AOP를 통해 해결해준다.
- AOP는 최후까지 애플리케이션 로직을 담당하는 코드에 남아있는 기술 관련 코드를 깔끔하게 분리해서 별도의 모듈로 관리하게 해주는 강력한 기술이다.

#### 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략
- 기술적인 코드, 침투적인 기술이 가져온 불필요한 흔적 등을 제거하고 나면 순수하게 애플리케이션의 주요 기능과 비즈니스 로직을 담은 코드만 독립적으로 존재하게 된다.
- 이중에서 기술적인 부분과 느슨하게나마 연관되는 데이터 처리 코드나 웹이나 리모트 인터페이스 코드등을 제외하면 비즈니스 로직 코드를 다루는 코드가 남는다.
- 비즈니스 로직을 담은 코드는 애플리케이션에서 가장 중요한 핵심이 되는 부분이며 업무의 변화에 따라 자주 변경되거는 부분으로 대체로 복잡하다.
- 애플리케이션 로직은 에러가 발생하더라도 서비스를 재시작하거나, 서버를 확장하면 되지만 비즈니스 로직에 문제가 발생하면 엄청난 사고로 이어질 수 있다.
- 은행에 계좌를 입금하여 돈은 나갔지만 입금이 되지않는 등에 대한 문제는 매우 큰 문제로 이어질 수 있다.
- 그러하여 이전에는 비즈니스 로직을 DB로 많이 관리하였지만 시스템이 복잡해질 수록 이는 더 위험해졌다.
- 그렇게 비즈니스 로직의 복잡함을 상대하는 전략은 자바라는 객체지향 기술 그 자체이다.
- 스프링은 스프링을 사용하더라도 자바 언어의 장점인 객체지향적인 특징을 살릴 수 있도록 설계되었기 때문에 이런 복잡함의 상대하는 전략인 자바의 객체지향적인 특징을 이용할 수 있게 되었다.

#### 핵심도구: 객체지향과 DI
- 지금까지 살펴봤듯이 기술적인 복잡함을 효과적으로 다루게 해주는 기법은 모두 DI를 바탕으로 하고 있다.
- 서비스 추상화, 템플릿/콜백, AOP와 같은 스프링 기술은 DI없이는 존재할수도 없는 기술들이다.
- 그리고 DI는 객체지향 설계 기술 없이는 그 존재의미가 없다.
- DI를 의식하다보면 오브젝트를 설계할 때 자주 DI를 적용할 후보를 찾게된다. 이는 성격이 다르고 변경의 이유가 다른 기능들을 구별할 수 있게되고 그런 후보들을 찾는다면 DI를 적용해서 오브젝트를 분리하고, 인터페이스를 도입하고 DI로 관계를 연결해주면 된다.
- 기술적인 복잡함을 해결하는 문제나 기술적인 복잡함이 비즈니스 로직에 침범못하도록 분리하는 경우에도 DI가 바탕이 된 여러 가지 기법들이 활용된다.
- 반면에 비즈니스 로직 자체의 복잡함을 해결하려면 DI보다는 객체지향 설계 기법이 더 중요하다.
- 스프링은 단지 코드가 단순해지고 명확해지기만을 위해 비즈니스 로직 자체를 기술적인 코드와 독립시킨것이 아니다.
- 그보다는 순수한 비즈니스 로직만을 담고 있는 코드에는 객체지향 분석과 설계에서 나온 도메인 모델을 쉽게 적용할 수 있기 때문이다.
- 기술적인 코드들이 침범하지 않는다면 더더욱 객체지향적인 특성을 살려 설계를 하기 쉬워질 것이다.

> 결국 모든 스프링의 기술과 전략은 객체지향이라는 자바 언어가 가진 강력한 도구를 극대화해서 사용할 수 있도록 돕는 것이라고 볼 수 있다.

---

## 8.3 POJO 프로그래밍
- 스프링의 목적은 애플리케이션 개발의 복잡함을 줄여주는 것 또는 효과적으로 대응하게 해주는 것이라고 하면 맞는 말이긴 하지만 좀 추상적이다.
- 기술적으로 스프링이 지향하는 목적이 무엇인지 정의해보자.
- 스프링의 핵심 개발자들은 **스프링의 정수는 엔터프라이즈 서비스 기능을 POJO에 제공하는 것** 이라고 한다.
- 엔터프라이즈 서비스라는 것은 보안, 트랜잭션과 같은 엔터프라이즈 시스템에서 요구되는 기술을 말한다.

### 8.3.1 스프링의 핵심: POJO
- 스프링 애플리케이션은 POJO를 이용해서 만든 애플리케이션 코드와, POJO가 어떻게 관계를 맺고 동작하는지를 정의해놓은 설계정보로 구분된다.
- 스프링의 주요 기술은 IoC/DI, AOP, PSA는 애플리케이션을 POJO로 개발할 수 있게 해주는 가능기술(enabling technology)라고 불리운다.

### 8.3.2 POJO란 무엇인가?
- 마틴파울러가 간단한 자바오브젝트를 조금 더 의미 있게 부르기 위해 Plain Old Java Object의 줄인 말인 POJO가 생겨났다.

### 8.3.3 POJO의 조건
- 단순하게 보면 그냥 평범한 자바오브젝트라고 할 수 있지만 좀 더 명확하게 하자면 적어도 다음의 세 가지 조건을 충족해야 POJO라고 불릴 수 있다.

#### 1)특정 규약에 종속되지 않는다.
- POJO는 자바 언어에 꼭 필요한 API 외에는 종속되지 않아야 한다.
- 스프럿츠 1과같이 특정 클래스를 상속해서 만들어야 하는 규약 같은것이 있다.
- 특정 규약에 종속된다면 객체지향적인 특성을 제대로 살릴 수 없다.
- 그러므로 별다른 가치를 주지도 못하는 규약에 종속되지 않고, 객체지향 설계의 자유로운 적용이 가능한 오브젝트여야만 POJO라고 불릴 수 있다.

#### 2)특정 환경에 종속되지 않는다.
- EJB3는 규약에 따라 오브젝트를 만들어야 하는 단점을 극복했지만 여전히 JNDI라는 서버 서비스 기술을 필요로 했따.
- 이렇듯 특정 환경에 종속된다면 POJO라고 할 수 없다. POJO는 환경에 독립적이어야 한다.
- 특히 비즈니스 로직을 담고 있는 POJO 클래스는 웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용해서는 안 된다.
- 설령 나중에는 웹 컨트롤러와 연결돼서 사용될 것이 뻔하다고 할지라도 직접적으로 웹이라는 환경으로 제한해버리는 오브젝트나 API에 의존해선 안된다.
- 그렇게 되면 웹외의 클라이언트가 사용하지 못하게 된다. 또 웹 서버에 올리지 않고 독립적인 테스트가 어려워진다.
- 비즈니스 로직을 담은 코드에 웹과 관려된 API가 등장하거나, 웹 프레임워크의 클래스를 직접 이용하는 부분이 있다면 그것은 진정한 POJO가 아니다.

> - 요즘은 소스코드에 직접 메타정보를 추가해주는 애노테이션을 많이 사용한다. 그렇다면 애노테이션을 사용했을 경우에는 POJO일까?
> - 메타정보들을 해당 클래스에 추가하니 POJO가 아니라고 할 수 있겠지만 꼭 그런건 아니다.
> - 애노테이션이 코드로 표현하기는 적절치 않은 부가적인 정보를 담고 있고, 그 때문에 환경에 종속되지만 않는다면 여전히 POJO라고 할 수 있다.
> - 하지만 애노테이션이나 엘리먼트 값에 특정 기술과 환경에 종속적인 정보를 담고 있다면 그때는 POJO로서의 가치를 잃어버린다고 할 수 있다.

#### 3)객체지향적인 설계
- 특정 규약이나 환경에 종속되지 않는다고 POJO라고할 수 없다.
- POJO는 객체지향적인 자바 언어의 기본에 충실하게 만들어져야 한다.
- 책임과 역할이 각기 다른 코드를 한 클래스에 몰아 넣어 덩치 큰 만능 클래스로 만드는 경우, 재사용이 불가능할 정도로 다른 레이어 영역의 코드와 강한 결합을 가질 경우, 상속과 다형성의 적용으로 처리하면 깔끔한 것을 if/switch 문이 가득 찬 길고 긴 메서드로 작성해놓은 경우등은 객체지향적인 특성을 잘 이용했다고 볼 수 없다.
- 이럴 경우 특정 규약, 환경에 종속되지 않는다고 해도 POJO라고 부를 순 없다.

> 진정한 POJO란 객체지향적인 원리에 충실하면서, 특정 환경이나 규약에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 만들어진 자바 오브젝트이다.

### 8.3.4 POJO의 장점
- POJO가 될수 있는 조건 그대로가 POJO의 장점이 된다.
- 특정한 기술과 환경에 종속되지 않는 오브젝트는 깔끔한 코드로 구성된다.
- POJO로 개발된 코드는 자동화된 테스트에 매우 유리하다.
  - 환경의 제약은 코드의 자동화된 테스트를 어렵게한다.
  - 컨테이너에서만 동작을 확인할 수 있다면 서버의 구동 및 빌드와 배치 과정까지 필요해질 것이다.
  - 이러한 불편함 때문에 수동화된 테스트를 사용할 것이고 이는 매우 효율적이지 않다.
- 객체지향적인 설계를 자유롭게 적용할 수 있다.

### 8.3.5 POJO 프레임워크
- 스프링은 POJO를 이용한 엔터프라이즈 애플리케이션 개발을 목적으로 하는 프레이워크이다.
- POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크를 POJO 프레임워크라고 한다.
- 스프링 프레임워크와 하이버네이트를 대표적인 POJO 프레임워크라고 꼽을 수 있다.
- 주로 DB 이용 기술에 POJO를 적용하는 것을 목적으로 하는 하이버네이트와 달리, 스프링은 엔터프라이즈 애플리케이션 개발의 모든 영역과 계층에서 POJO 방식의 구현이 가능하게 하려는 목적으로 만들어졌다.

---

## 8.4 스프링의 기술
- 스프링에는 POJO 프로그래밍을 손쉽게 할 수 있도록 지원하는 세 가지 가능기술을 제공한다.
- IoC/DI, PSA, AOP이다.
- 사실 이들은 객체지향 적인 설계와 개발원리를 잘 적용하다보면 자연스럽게 만들어지는 것이기도하다.
- 다만 스프링은 그것을 통일설 있게, 더 세련된 방법으로, 자바 엔터프라이즈 개발의 전 영역에 걸쳐 효과적으로 적용될 수 있도록 프레임워크 형태로 제공하고 있다.
- 스프링의 기술들은 스프링 프레임워크가 만들어진 진정한 목표인 POJO 기반의 엔터프라이즈 개발을 편리하게 해주는 도구일 뿐이다. 또 다른 관점에 보자면 IoC/DI, AOP, PSA라는 것 자체가 이미 스프링이 중요한 가치를 두는 객체지향의 원리를 충실히 적용해서 나온 결과이기도 하다.
- 스프링은 다양한 기술에 대해 이미 잘 만들어진 서비스 추상화를 제공하지만, 스프링 사용자라면 스프링이 직접 제공하지 않는 기술에 대해서도 PSA를 적용할 줄 알아야 한다.
- 그것이 스프링의 목적과 개발철학에 부합하는 스프링의 사용법이다.

### 8.4.1 제어의 역전(IoC) / 의존관계 주입(DI)
- IoC/DI는 스프링의 가장 기본이 되는 기술이자 스프링의 핵심 개발 원칙이기도 하다.
- 나머지 두가지 기술인 AOP와 PAS도 IoC/DI에 바탕을 두고 있다.
- 3대 기술은 아니지만 자주 등장하는 템플릿/콜백 패턴이 적용된 부분도 IoC/DI가 그 핵심 원리이다.
- 왜 두 개의 오브젝트를 분리해서 만들고, 인터페이스를 두고 느슨하게 연결한 뒤, 실제 사용할 대상은 DI를 통해 외부에서 지정하는 것일까?
- 변경에는 닫혀이고 확장에는 열려있는 OCP의 관점을 생각해보면된다.
- A->B라는 의존관계를 갖는 오브젝트 구조가 있을 때 확장은 B가 자유롭게 변경될 수 있음을 뜻한다.
- 이는 B가 변경돼도 A는 아무런 영향을 받지 않고 그대로 유지 가능하다는 뜻이기도 하다.
- B관점에서는 유연한 확장이고 A관점을보자면 변경 없이 재사용이 가능하다고 볼 수 있는 것이다.
- B1, B2, B3로 구현이 바뀌어도 A는 그대로 재사용할 수 있다.

#### DI의 활용법
**핵심기능의 변경**
- DI를 활용하면 해당 인터페이스의 구현체를 변경할 수 있으므로 자유롭게 핵심기능을 변경할 수 있다.

**핵심기능의 동적인 변경**
- DI를 잘 활용하면 애플리케이션이 동작하는 중간에 그 의존 대상을 다이내믹하게 변경할 수 있다.
- 예를들어 사용자의 등급에 따라 다른 DataSource를 사용하게 만들 수 있다.
- DAO->DataSource 관계가 만들어지는데 이를 DAO 하나가 여러 DataSource에게 의존하게 만들 수 있다.
- 그리고 현재 사용자의 등급에 따라 그때그때 다른 DataSource를 DAO가 사용하게 할 수도 있다.
- VIP 사용자는 좀 더 속도가 빠른 DB를 이용하게 해서 빠른 처리 속도를 보장해주려고 할 때 적용할 수 있는 기법이다.
- 동적인 방식으로 핵심기능을 변경하는 건, 기술적으로 보자면 다이내믹 라우팅 프록시나 프록시 오브젝트 기법을 활용한 것이다.

**부가기능의 추가**
- 핵심기능을 그대로 둔 채 부가기능을 추가할 수 있다.
- 데코레이터 패턴을 생각해보면 된다. 인터페이스를 두고 사용하게 하고, 실제 사용할 오브젝트는 외부에서 주입하는 DI를 적용해두면 데코레이터 패턴을 쉽게 적용할 수 있다.
- 핵심기능과 클라이언트 코드에는 전혀영향을 주지 않으면서 부가적인 기능을 얼마든지 추가할 수 있다.
- 트랜잭션 기능을 부여했던것이 대표적인 예이다. 때로는 핵심 기능을 그대로 둔채 결과나 전달 파라미터를 조작할 수 있고, 파라미터나 리턴 결과를 활용해 로깅이나 보안 처리 같은 부가적인 작업을 수행할 수도 있다.
- 이러한 부가기능들을 일반화시키면 AOP가 될것이고 AOP도 결국 DI구조로 인해 만들어질 수 있는 방법중 하나이다.

**인터페이스의 변경**
- 때로는 사용하려고 하는 오브젝트가 가진 인터페이스가 클라이언트와 호환되지 않는 경우가 있다.
- 또는 여러 종류의 인터페이스를 가졌지만 사실은 비슷한 기능을 담당하는 오브젝트를 바꿔가면서 사용하고 싶을 때도 있다.
- 이렇게 사용하는 인터페이스와 실제 오브젝트 사이에 인터페이스가 일치하지 않는 경우도 DI가 유용하다.
- A가 C를 사용하려고하지만 A->B 구조로 이루어져 있다면 어댑터 패턴을 활용하여 A->B(위임)->C의 형태로 기능을 구현하면 될 것이다.
- 이를 조금 더 일반화해서 아예 인터페이스가 다른 다양한 구현을 같은 방식으로 사용하도록 중간에 인터페이스 어댑터 역할을 해주는 레이어를 하나 추가하는 방법도 있다.
- PSA가 이런 방식으로 구성되었다. PSA는 클라이언트가 일관성 있게 사용할 수 있는 인터페이스를 정의해주고 DI를 통해 어댑터 역할을 하는 오브젝트를 이용하게 해준다.

**프록시**
- 필요한 시점에 실제 사용할 오브젝트를 초기화하고 리소스를 준비하게 해주는 지연로딩을 적용하려면 프록시가 필요하다.
- 원격 오브젝트를 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사용할 수 있게 해주는 원격 프록시를 적용하려고 할 때도 프록시가 필요하다.
- 두 가지 방법 모두 DI를 필요로 한다.

**템플릿과 콜백**
- 템플릿/콜백 패턴은 DI의 특별한 적용 방법이다.
- 반복적으로 등장하지만 항상 고정적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 분리해서 템플릿과 콜백으로 만들고 이를 DI 원리를 응용해 적용하면 지저분하게 매번 만들어야 하는 코드를 간결하게 만들 수 있다.
- 스프링이 제공하는 20여 가지의 템플릿/콜백이 적용된 기능을 가져다 활용할 뿐만아니라 필요에 따라서 직접 응용할 수 있어야 한다.
- 콜백을 템플릿에 주입하는 방식으로 동작하게 하는것은 DI의 원리에 가장 충실한 응용법이다.
- 콜백을 얼마든지 만들어서 사용할 수 있다는 건 개방을 통한 유연한 확장성을 보여주는 것이며, 템플릿은 한 번 만들어두면 계속해서 재사용할 수 있다는 건 기능의 확장에도 변하지 않는다는 OCP에 잘 들어맞다.

**싱글톤과 오브젝트 스코프**
- DI가 필요한 중요한 이유 중 한가지는 DI 할 오브젝트의 생명주기를 제어할 수 있다는 것이다. DI를 프레임워크로 이용한다는 건 DI 대상 오브젝트를 컨테이너가 관리한다는 의미이다.
- DI가 대상 오브젝트의 모든 과정을 주관하므로 스코프를 자유롭게 제어할 수 있다.

**테스트**
- 오브젝트와 협력해서 동작하는 오브젝트를 효과적으로 테스트 하는 방법은 가능한 한 고립시키는 것이다.
- 그래야만 테스트 대상인 오브젝트의 기능을 충실하게 테스트할 수 있다.
- DI를 활용하였다면 스텁, 목 객체를 주입하여 어렵지 않게 단위 테스트를 진행할 수 있다.

### 8.4.2 AOP
- IoC/DI를 이용해서 POJO에 선언적이 엔터프라이즈 서비스를 제공할 수 있지만 일부 서비스는 순수한 객체지향 기법만으로는 POJO의 조건을 유지한 채로 적용하기 힘들다.
- 바로 이런 문제를 해결하기 위해 AOP가 필요하다. 스프링의 AOP는 스프링이 POJO 프로그래밍을 지원하려는 그 핵심 목적을 위해 중요한 역할을 하고 있다.
- 스프링에서 제공하는 가장 기본적인 AOP는 트랜잭션과 @Configuration 애노테이션을 이용해서 도메인 오브젝트에 DI를 자동적용해주는 AOP기능이다..
- @Configuration을 위해서는 AspectJ를 이용한 AOP가 반드시 필요하다.

#### 8.4.3 PSA
- 스프링이 제공해주는 트랜잭션과 같은것을 충분히 활용하면서 필요에 따라 직접 추상화를 만들어 사용하자.
- 스프링이 지원해줄때까지 기다리는게 아닌 스프링이 그랬던 것처럼 직접 추상 레이러를 도입하고 일관성 있는 API를 정의해서 사용해보자.
