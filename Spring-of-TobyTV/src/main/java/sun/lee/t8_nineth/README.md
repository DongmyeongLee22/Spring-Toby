# \# 9. Reactive Streams (5) 비동기 RestTemplate와 비동기 MVC/Servlet
- 지난번에 여러가지 비동기 처리를 알아보았지만 사실 그 방식만으로는 효율적으로 사용하기엔 무리가 있다.
- 실제 서버에는 백단의 여러가지 비즈니스 로직들이 있는데 이러한 경우 단순히 비동기 서블릿으로 문제를 해결할 수 없다.
- 요즘에는 하나의 시스템에도 여러 프론트서버와, 백엔드서버, 데이터베이스 서버가 분리되어있게 된다.
- 프론트에서 백엔드에서 요청을할 때 해당 결과를 올 떄까지 프론트단의 쓰레드가 반환되지 않고 계속해서 대기하고 있기 때문에 백엔드가 반환해줄 때 까지 쓰레드를 물고 있어 프론트단의 쓰레드들은 반환되지 않고 응답을 기다리기 때문에 심각한 지연이 발생한다.
- 이를 어떻게 해결해야하는지 하나씩 알아보자.

### 테스트를 위한 설정들..
#### [RemoteService](RemoteService.java)
- 요청을 받은 서버에서 한번 더 요청을 할 수 있는 서버를 정의한다.
- 핸들러들을 보면 단순 String을 반환하지만 2초동안 딜레이가 있다.

#### [Test](LoadTest.java)
- Url 매핑값을 파라미터로 가지는 test메서드가 존재한다.
- 해당 테스트는 100개의 쓰레드풀을 만들고 각 쓰레드별로 서버에게 요청을 보내 총 100번의 요청을 보낸다.
- CyclicBarrier를 이용하여 쓰레드들을 담아놓고 한번에 동작시키게 정의하였다.
- 각 요청이 처리되는 시간과 요청이 다 처리된 후의 시간을 로깅한다. 
- 각 Controller에 main 메서드를 생성하고 main 메서드에서 테스트를 수행한다.

#### 쓰레드 설정
- 클라이언트의 요청을 받는 서버의 쓰레드는 1개로 설정한다.
- 서버에서 또 API를 요청하는 서버는 쓰레드 개수를 1000개로 설정한다.
---

### [1. RestTemplate](Ex1_1MyController.java)
- RestTemplate는 블록킹방식으로 동작하기 때문에 요청마다 새로운 쓰레드를 만들어야 한다.
- 현재 쓰레드는 1개로 설정되어 있기 때문에 외부 API에 요청을 블록킹 방식으로 한번씩 진행하므로 총 2 * 100초가 걸린다.
- 이 뜻은 쓰레드가 하나일 경우 CPU는 제대로된 작업을 수행하징 않고 응답을 기다리게 되므로 매우 비효율적이다.

### [2. AsyncRestTemplate](Ex2_1MyController.java)
- RestTemplate에서 비동기 방식을 지원하기 위한 AsyncRestTemplate이 생겨났다.
- AsyncRestTemplate로 외부 API를 요청하면 2~3초의 시간이 걸린다.
- 즉 하나의 쓰레드로 비동기 방식을 통해 요청을 수행한 것이다.
- 하지만 이 방식은 JMC와 같은 툴을 통해 쓰레드수를 확인해보면 **내부적으로 100개의 쓰레드를 만들어 수행하는 것을 알 수 있다.**
- 이는 겉으로 느끼기에는 비동기 방식이 적용된거 같지만 사실은 쓰레드들을 많이 만들어 메모리를 사용한 것이다.

> AsyncRestTemplate은 Deprecated되었고 WebClinet를 사용하기를 권고하지만 테스트중이니 이를 사용하자.

### [3. AsyncRestTemplate With Netty](Ex3_1MyController.java)
- 이번엔 AsyncRestTemplate를 Netty기반으로 생성하고 하나의 쓰레드로만 설정하여 테스트를 진행해보자.
- 해당 결과도 약 2~3초의 시간이 걸리므로 2.의 테스트와 동일하다.
- 하지만 이는 내부적으로 쓰레드를 만들지 않고 netty기반의 nioEventLoopGroup쓰레드 하나로만 요청이 처리된다.
- 즉 2.의 방식과 속도는 거의 똑같지만 메모리 사용량은 매우 차이가 날것이다.
- 외부 API요청을 ListenableFuture로 반환받고 콜백과 DeferredResult를 이용하여 추가작업을 수행할 수도 있다.

### [4. AsyncRestTemplate With Netty (Callback Hell)](Ex4_1MyController.java)
- 클라이언트의 요청을 받았을 때 외부 API의 요청을 1번이 아닌 여러번을 수행할 수도 있다.
- ListenableFuture의 콜백안에서 또 API요청을 처리하면된다.
- 그리고 그 안에 또 내부 비동기 작업을 수행할 수도 있다.
- 테스트를 돌려보면 두번의 비동기 요청을하니 약 4초의 시간이 걸리는것을 알 수 있다.
- 하지만 코드들을 보면 읽기 쉽지 않는것을 알 수 있다.
- 흔히 이를 콜백지옥이라고한다. 
- JS공부할 때 흔히 보았던 콜백지옥..

> 다음번엔 이 콜백지옥을 해결하는 방법을 알아보도록 한다. JS처럼 then-catch 갔다가 async-awiat 방식처럼 진행되지 않을까?

