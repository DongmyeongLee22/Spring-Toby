# \# 8. Reactive Streams (4) 자바와 스프링의 비동기 기술
- 왜 스프링이 기존에 있는 스프링 MVC가 아닌 엔진까지 바꿔가며 새로운 웹플럭스를 만드는지 알아보자.
- 옛날방식의 비동기 프로그래밍을 하나씩 구현해보면서 알아보자.

### [1. Future](Ex1Future.java)
- 자바에서 가장 기본이 되는 비동기 처리 결과를 받아오는 인터페이스이다.
- ExecutorService에서 Callable을 파라미터로 가지는 submit메서드의 반환 타입이 Future이다.
- Future를 이용하면 비동기 처리 결과를 받아올 수 있는데 Future.get()을 호출할 때 블럭킹이 되면서 해당 결과를 가져오게 된다.
- [Ex2Future](Ex2Future.java)와 같이 Future.isDone()을 활용하여 처리가 다 되었을때 get()을 요청하여 블럭킹상황을 예방할 수 있다.

### [2. FutureTask](Ex4Callback.java)
- 콜백형식으로 비동기 처리를 할 수 있게 지원해주는 Future의 구현체이다.
- FutureTask에는 비동기 처리가 끝나면 호출되는 done()메서드가 존재한다.
- 이를 이용해 해당 메서드 내에서 콜백스타일로 기능을 구현하면 Futue보다 간단하게 구현이 가능해진다.

---

### [3. SpringAync](Ex5SpringAsync.java)
- 스프링서버에서도 Async Annotation을 붙이면 Future를 통해 비동기 처리가 가능하다.
- 현재는 리턴 값이 있지만 보통 이런 비동기 작업은 매우 긴 배치작업에 사용하고 해당 결과를 디비에 넣고 나중에 필요할 때 찾아오는 방식으로 사용할 때 유용하다.
- 혹은 세션에 넣은 후 isDone()이 true일 경우에 get()을 하는 방식을 사용할 수도 있다.
- @Async는 매번 쓰레드를 만들기 때문에 Excutor를 따로 빈으로 등록해주어야 자원을 효율적으로 사용할 수 있다.
- ListenableFutue를 통해 콜백형식으로 구현할 수도 있다.


## 비동기 서블릿
- 비동기 서블릿의 특징을 먼저 이해해보자.

### 서블릿 3.0 이전
- 서블릿 3.0이전에는 블럭킹구조이기 때문에 항상 I/O마다 쓰레드를 할당하였다.
- 그렇기 때문에 커넥션당 쓰레드를 하나씩 할당하였다.
- HttpReq, Res에서 사용하는 **InputStream, OutStream이 블럭킹 방식으로 동작되기 때문이다.**
- 블럭킹되는 순간 컨텍스트 스위칭이 일어나기 때문에 오버헤드가 발생할 수 있다.
- 그렇기 때문에 블럭킹 I/O를 많이 사용하면 CPU자원을 많이 소모될 수 있다.
- 쓰레드가 차서 큐에 담기기 때문에 레이턴스가 높아지고 쓰루풋은 낮아진다.

### 서블릿 3.0 이후
- 서블릿 3.0부터 비동기로 서블릿 처리기능이 추가됨

1         ServletThread1 -> req -> WorkThread[blocking IO(DB, API)] -> res(html)
2         ST2
3   NIO   ST3
4         ST4
5         ST5

- WorkThread의 작업때문에 서블릿 쓰레드가 쓸데없이 대기하는 것은 매우 비효율적이다.
- 이를 해결하기 위해 쓰레드를 많이 두더라도 컨텍스트 스위칭 오버헤드가 있기 때문에 문제가 발생할 수 있다.
- **비동기 서블릿은** WorkThread에서 작업을 수행중일 땐 ServletThread는 풀에다가 반환할 수 있게하는 기술이다.
- 서블리 3.0에 생겨났지만 그 당시에는 I/O가 블록킹이여서 완벽한 비동기 처리가 불가능했다.
- **3.1에서는** **I/O를 논블록킹**으로 구현하여 **Callback**을 통해 **비동기 논블록킹으로 개발**이 가능하다.

> - 서블릿 쓰레드는 NIO Connector에서 요청을 받아서 파싱하고 작업 쓰레드에게 넘기고 쓰레드 서블릿은 반환된다.
> - 작업 쓰레드가 결과를 돌려주면 다른 쓰레드 서블릿이 그걸 받아서 다시 결과를 리턴해준다.
> - 예시를 통해 해당 기능을 테스트해보자.

### [4. 비동기 서블릿](Ex6_1SpringWebAsync.java)
- 먼저 /async로 url매핑이 되어있는 핸들러를 [Test](Ex6_2LoadTest.java)를 통해 테스트를 해보자.
- 해당 핸들러는 String타입을 리턴하고 테스트에서는 동일한 요청을 100번보내도록 구성되어있다.
- 톰캣의 기본 쓰레드풀 개수는 200개이므로 모든 요청은 약 2초만에 끝나게 될 것이다.
- 톰캣의 기본 쓰레드풀 개수를 20개로 줄이게되면 100개의 요청이 20개의 쓰레드레서 동작하므로 약 10초 가량 시간이 소모된다.
- 이제 Callable타입을 리턴하는 /callable로 url 매핑이되어있는 핸들러를 테스트해보자.

**나는 테스트가 제대로되지 않지만 토비님 테스트로 확인된 것**
- 해당 핸들러는 서블릿 비동기 처리를 하기때문에 20개의 서블릿 쓰레드가 있더라도 약 2초만에 작업이 완료된다.
- 비동기 처리로인해 서블릿 쓰레드는 작업 쓰레드에게 작업이 넘어가면 서블릿 쓰레드를 반환하기 때문에 **작업 쓰레드가 100개** 생길 것이고 서블릿 쓰레드는 해당 작업이 끝날 때 결과를 리턴해주므로 쓰레드가 20개 있더라도 시간 지연이 없다.
- 그 뜻은 쓰레드를 한개로 줄여도 약간의 시간 지연이 있을뿐 2초대로 결과를 받아올 수 있게 된다.

> 나는 왜 10초보다 더 걸리는지?? 원인을 모르겠다..

---

### [4. Spring DeferredResult](Ex7_1SpringDeferredResult.java)
- 스프링에서는 외부의 이벤트가 발생했을 때 기존에 대기중인 요청에 대한 응답을 쓰게해주는 DeferredResult가 있다.
- DeferredResult는 setResult, setException과 같은 메서드가 호출 될 때 까지 응답을 보내지 않고 대기를 시키지만 서블릿 쓰레드는 반환되기 때문에 쓰레드사용을 최소화할 수 있다.
- 그리고 워커 쓰레드도 만들지 않고 DeferredResult를 Queue에 담아 메모리에 유지만 하더라고 동작시킬 수 있다.
- [Test](Ex7_2LoadTest.java)를 동작시키고 dr/count를 확인해보면 큐가 100개 찼을테니 100이 나타난다.
- 그 후에 dr/event?msg=Result를 요청해주면 그 때 setResult가 발생하여 모든 요청이 동시에 처리되는 것을 알 수 있다.

### [5. Spring Emitter](Ex8Emitter.java)
- 하나의 HTTP요청에 여러번의 데이터를 나누어서 여러번의 응답을 해주는 Emitter도 스프링에서 간단하게 사용할 수 있다.
- ResponseEmitter를 통해 응답을 처리하면 된다.
- 해당 코드에 매핑된 url로 접속해보면 텍스트가 100ms마다 순서대로 나타나는 것을 알 수 있다.

