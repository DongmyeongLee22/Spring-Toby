# \# 2. 수퍼 타입 토큰
- 특정 타입을 Key로 가지고 오직 해당 타입에 맞는 데이터만 Value로 가질 수 있는 TypeSafeMap을 만들어보면서 수퍼타입 토큰에 대해 이해한다.

### [V1 타입 토큰 만들기](V1TypeToken.java)
- Typesafe한 Map을 만들었다.
- 해당 Map은 put을 할 때 특정한 타입의 클래스 정보를 넘기고 해당 타입에 맞는 데이터만 담을 수 있도록 제네릭스를 활용했다.
- 이렇게 특정 타입의 클래스 정보를 넘겨서 타입 안전성을 보장하는 방법을 '타입 토큰' 기법이라고 한다.
- 하지만 출력을 보면 List\<Stirng>, List\<Integer>는 하나의 List.class로 보기때문에 덮어쓰기가 되어버린다.
- 이럴때 '수퍼 타입 토큰'을 활용하면 해결 할 수 있다.

### [V2 수퍼 타입 토큰 만들기](V2SuperTypeToken.java)
- 해당 클래스의 step1, 2, 3 메서드별로 묶어서 정리

#### 1) Step1 Method
- Sup\<T> 만으로는 자바 제네릭스는 이레이저가 적용되기 때문에 원하는 결과가 나오지 않는 것을 알 수 있다.

#### 2) Step2 Method
- Sup\<T>에서 T에 구체적인 타입을 지정하여 상속을 받은 Sub 클래스들을 정의한다.
- 그 후 그 Sub클래스에서는 리플렉션을 통해 T 타입을 가져올 수 있게 된다.
- 리플렉션을 통해 가져오면 해당 정보가 바이트코드에 저장되기 때문에 List\<Integer>, List\<String>수준의 정보까지 구분해서 알아낼 수 있다.
- Sub 클래스는 지역 클래스, 혹은 익명 클래스로 바로 작성하여도 똑같이 동작되는 것을 확인할 수 있다.
- 이 방법을 이용하면 수퍼타입 토큰을 만들 수 있다.

#### 3) Step3 Method
- 수퍼타입 토큰 Map을 만들기 위해 우선 TypeReference 클래스를 만들었다.
- TypeReference는 Type을 멤버로 가지고 있고 생성될때 정의된 타입을 step2에서 했던거처럼 가져와서 type멤버에 정의해준다.
- 정의하는 타입이 아닌 생성자의 \<>에 타입을 넣어줘야한다. 왜냐하면 정의하는 타입은 런타임에 남아있는 정보가 아니기 때문이다.
- step3 메서드 결과를 확인해보면 수퍼 타입 토큰이 제대로 동작하는 것을 알 수 있다.

### [V3 수퍼 타입 토큰 스프링에서 활용하기](V3SpringTypeReference.java)
- 스프링에서는 ParameterizedTypeReference을 통해 수퍼 타입 토큰을 지원해준다.
- 그러므로 직접 만들 필요는 없다.
- 이 수퍼 타입 토큰을 활용할 수 있는 좋은예는 RestTemplate를 사용할 때 이다.
- RestTemplate를 사용할때 제네릭정보가 없는 User만 받을 경우는 바로 받아올 수 있다.
- 하지만 List\<User>와 같이 제네릭 정보가 있을 경우 해당 결과값을 Map으로 받아와 map.get("name")과 같이 해당 데이터들을 가져온다.
- 이럴 때 수퍼타입 토큰을 사용하면 타입을 바로 받아올 수 있게 된다.
